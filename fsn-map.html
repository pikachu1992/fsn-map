<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../google-map/google-map.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="../paper-progress/paper-progress.html">

<dom-module id="fsn-map">
  <template>
    <style>
      :host {
        display: block;
      }
      paper-progress {
        display: block;
        width: 100%;

      }
      paper-fab {
        position: absolute;
        bottom: 10px;
        right: 10px;
      }
    </style>

    <iron-ajax
          
          id="ajax"
          url="https://vatsim-status-proxy.herokuapp.com/clients"
          handle-as="json"
          last-response="{{_pilots}}"
          on-response="_plotPilotMapMarkers"
          loading="{{_clientAjaxLoading}}"></iron-ajax>

    <iron-ajax
          auto
          id="firs"
          url="https://v4p4sz5ijk.execute-api.us-east-1.amazonaws.com/anbdata/airspaces/zones/fir-list"
          params='{"api_key":"2a877ab0-4ed2-11e7-9b2e-d3182793b831", "firs": "", "format": "json"}'
          handle-as="json"
          last-response="{{firs}}"
          on-response="handleFirs"
          debounce-duration="3000"></iron-ajax>

    <paper-progress indeterminate id="progress"></paper-progress>
    <google-map
          additional-map-options='{"mapTypeId":"satellite"}'
          disable-default-ui
          fit-to-marker
          api-key="AIzaSyDj4y39JAORYGw4rNcA1y8oVj0m8lNDje4"
          latitude="40.0955474"
          longitude="-3.070306"
          zoom="4"
          drag-events="true"
          id="map"></google-map>

  </template>

  <script>
    /**
     * `fsn-map`
     * Dynamic flight sim traffic map
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class FsnMap extends Polymer.Element {
      static get is() { return 'fsn-map'; }

      static get observers() {
        return [
            '_clientAjaxLoadingChanged(_clientAjaxLoading)'
        ]
      }
      static get properties() {
        return {
          /**
          * Viewport center position at time of last data provider call
          */
          _lastRequestedCenter: {
            type: Object
          },
          /**
          * Viewport size at time of last data provider call
          */
          _lastRequestedViewportDistance: {
            type: Number
          },
          _pilotPlotTickCounter: {
            type: Number,
            value: 1
          },
          _clientTimerTickCounter: {
            type: Number,
            value: 1000
          },
          _clientTimerLimit: {
            type: Number,
            value: 10000
          },
          _clientAjaxLoading: {
            type: Boolean,
            notify: true,
            value: false
          },
          lastLatitude: {
            type: Number,
            value: 0
          },
          lastLongitude: {
            type: Number,
            value: 0
          },
          lastZoom: {
            type: Number,
            value: 0
          },
          _aircraftMarkers: {
            type: Array,
            value: {}
          },
          selectedPilot: {
            type: String,
            value: ''
          },
          updating: {
            type: Boolean,
            value: false
          }
        }
      }
      ready() {
        super.ready();

        // map events binding
        this.$.map.addEventListener('google-map-drag', e => {this._mapViewportUpdate(e)});
        this.$.map.addEventListener('zoom-changed', e => {this._mapViewportUpdate(e)});

        // schedule update
        window.requestAnimationFrame(this._clientTimerTick.bind(this));
        window.requestAnimationFrame(this._pilotPlotTick.bind(this));
      }
      _pilotPlotTick() {
        // every second
        if (this._pilotPlotTickCounter % 1000 == 0) {
          this._pilotPlotTickCounter = 1;
          this._plotPilotMapMarkers();
        }
        this._pilotPlotTickCounter++;
        window.requestAnimationFrame(this._pilotPlotTick.bind(this));
      }
      _clientTimerTick() {


        // every 100ms
        if (this._clientTimerTickCounter % 100 == 0) {

          if (!this.$.map.map) {
            this._clientTimerTickCounter = 0;
          }

          if (this._clientAjaxLoading) {
            this._clientTimerTickCounter = 0;
          }

          if (this._clientTimerTickCounter >= this._clientTimerLimit || this._mapDragRequiresUpdate()) {
            this._clientTimerTickCounter = 0;
            if (this.$.ajax.lastRequest) {
              this.$.ajax.lastRequest.abort();
            }

            // do ajax request
            // console.log("request");
            this.$.ajax.params = this.computeParams();
            this.$.ajax.generateRequest();
          }
        }

        // console.log("this._clientTimerTickCounter++;");
        this._clientTimerTickCounter++;
        window.requestAnimationFrame(this._clientTimerTick.bind(this));
      }
      _clientAjaxLoadingChanged(loading) {
        if (loading) {
          this.$.progress.indeterminate = true;
        } else {
          this.$.progress.indeterminate = false;
        }
      }
      handleFirs() {
        var firs = this.firs;

        // parse FIRs
        for (var i = 0, len = firs.length; i < len; i++) {
          var fir = firs[i];
          
          // parse geometries
          var _coordinates = undefined;
          var geometry = fir.geometry;
          if (geometry.type == "Polygon") {
            var _coordinates = geometry.coordinates[0];            
          } else if (geometry.type == "MultiPolygon") {
            var _coordinates = geometry.coordinates[0][1];
          }
          if (_coordinates != undefined) {
            var coordinates = this._getFirCoordinates(_coordinates);
            var firGeometry = new google.maps.Polyline({
              path: coordinates,
              geodesic: true,
              strokeColor: "#FFF",
              strokeOpacity: 0.4,
              strokeWeight: 0.7
            });
            firGeometry.setMap(this.$.map.map);
          }
        }
      }
      _getFirCoordinates(_coordinates) {
        var coordinates = [];   
        for (var coordinatesIndex = 0, len = _coordinates.length; coordinatesIndex < len; coordinatesIndex++) {
          coordinates.push({lat: _coordinates[coordinatesIndex][1], lng: _coordinates[coordinatesIndex][0]});
        }
        return coordinates;
      }
      _getClientMarkerIcon(client) {
        // determine x coordinate in aircraft sprite image
        var client_x_sprite = parseInt(client.heading);
        if (client_x_sprite > 180) {
          client_x_sprite = client_x_sprite - 180;
        } else {
          client_x_sprite = client_x_sprite + 180;
        }
        client_x_sprite = Math.round(Math.abs(client_x_sprite / 15));

        // return actual image
        return {
          url: '../aircraft-yellow-icons.png',
          // This marker is 20 pixels wide by 32 pixels high.
          size: new google.maps.Size(23, 23),
          // The origin for this image is (0, 0).
          origin: new google.maps.Point(client_x_sprite * 48, 3 * 48),
          // The anchor for this image is the base of the flagpole at (0, 32).
          anchor: new google.maps.Point(11.5, 11.5)
        };
      }
      _mapDragRequiresUpdate() {

        /*
        * Early exit conditions
        */

        // if map is not ready, no reason to pull data
        if (this.$.map.map == null) {
          return false
        }

        /*
        * Verified conditions
        */

        // if no last update, grab some data
        if (!this._lastRequestedCenter) {
          this._lastRequestedCenter = this.$.map.map.getCenter();
          return true
        }

        // map viewport deslocation requires new data
        var southwest = this.$.map.map.getBounds().getSouthWest();
        var northeast = this.$.map.map.getBounds().getNorthEast();
        var distance = southwest && northeast ? google.maps.geometry.spherical.computeDistanceBetween(southwest, northeast) : 10000;
        if (google.maps.geometry.spherical.computeDistanceBetween(this._lastRequestedCenter, this.$.map.map.getCenter()) > distance / 2) {
          this._lastRequestedCenter = this.$.map.map.getCenter();
          return true
        }

        /*
        * No matching condition
        */
        return false
      }
      _mapViewportUpdate(e, force=false) {
        this.$.ajax.params = this.computeParams();
        this._lastRequestTryCounter++;

        if (force) {
          this.$.ajax.generateRequest();
        }

        // if (this._lastRequestTryCounter <= 5000) {
        //   console.log("(this._lastRequestTryCounter <= 5000000) " + this._lastRequestTryCounter);
        //   return
        // }

        if (!this._mapDragRequiresUpdate()) {
          return
        }

        this.$.ajax.generateRequest();
      }
      static toRad(degree) {
         return degree * Math.PI / 180;
      }
      static toDeg(radian) {
         return radian * 180 / Math.PI;
      }
      _calculateClientMovement(client) {
        // calculate traveled distance in nautical miles
        // get time traveled
        var now = new Date();
        var updated = new Date(Date.parse(client['_updated']));
        if (updated > now) {
          updated.setDate(updated.getDate() + 1);
        }
        var hoursTraveled = (now - updated)/36e5;
        var kmTraveled = (client.groundspeed * hoursTraveled) * 1.609344;

        // calculate new location
        var currentLocation = new google.maps.LatLng(client['location'][1], client['location'][0]);

        kmTraveled = kmTraveled / 6371;  
        var heading = FsnMap.toRad(client.heading);

        var lat1 = FsnMap.toRad(currentLocation.lat()), lon1 = FsnMap.toRad(currentLocation.lng());

        var lat2 = Math.asin(Math.sin(lat1) * Math.cos(kmTraveled) + 
                            Math.cos(lat1) * Math.sin(kmTraveled) * Math.cos(heading));

        var lon2 = lon1 + Math.atan2(Math.sin(heading) * Math.sin(kmTraveled) *
                                     Math.cos(lat1), 
                                     Math.cos(kmTraveled) - Math.sin(lat1) *
                                     Math.sin(lat2));

        client['location'][0] = FsnMap.toDeg(lon2);
        client['location'][1] = FsnMap.toDeg(lat2);

        return client
      }
      _plotPilotMapMarkers() {
        if (this._pilots == undefined) {
          return
        }

        for (var pilotIndex = 0, len = this._pilots._items.length; pilotIndex < len; pilotIndex++) {
          var pilot = this._pilots._items[pilotIndex];
          // console.log("pilot #" + pilotIndex);

          // update markers
          var marker = this._aircraftMarkers[pilot.callsign + pilot.cid];
          var pilot = this._calculateClientMovement(pilot);
          if (marker != undefined) {
            // update existing marker
              marker.setPosition({lat: pilot['location'][1], lng: pilot['location'][0]});
              marker.setIcon(this._getClientMarkerIcon(pilot));
              // console.log("update " + marker);
          } else {
            // create and save a new marker
            marker = new google.maps.Marker({
              position: {lat: pilot['location'][1], lng: pilot['location'][0]},
              map: this.$.map.map,
              label: pilot.route,
              icon: this._getClientMarkerIcon(pilot),
              title: pilot.callsign + ' ' + pilot.realname
            });
            this._aircraftMarkers[pilot.callsign + pilot.cid] = marker;
            // console.log("create " + marker);
          }
        }
      }
      _computeWhere() {

        if (!this.$.map.map.getBounds()) {
          return '{"clienttype": {"$eq": "PILOT"}}';
        }

        // center point
        var center = this.$.map.map.getBounds().getCenter();

        // get distance from southwest to northeast corner
        var southwest = this.$.map.map.getBounds().getSouthWest();
        var northeast = this.$.map.map.getBounds().getNorthEast();

        // get view port distance
        var distance = southwest && northeast ? google.maps.geometry.spherical.computeDistanceBetween(southwest, northeast) : 10000;

        // TODO: Parse the MongoDB query below appropriately
        //console.log('{"location": {"$near":{ "$geometry": {"type": "Point", "coordinates": [' + center.lng() + ', ' + center.lat() + ']}, "$maxDistance": ' + Math.floor(distance) + '}}}');
        return  ['{ "$and": [ ',
                [
                  '{"clienttype": {"$eq": "PILOT"}}',
                  '{"location": {"$near":{"$geometry": {"type": "Point", "coordinates": [' + center.lng() + ', ' + center.lat() + ']}, "$maxDistance": ' + Math.floor(distance) + '}}}',
                  // TODO: append params here
                  //'{"callsign": {"$regex": "^(TAP|TSZ).*$", "$options": "im"}}',
                ].join(','),
                '] }'].join('');
}
      computeParams() {
        return {where: this._computeWhere(), projection: '{"_updated": 1, "_created": 1, "callsign": 1, "cid": 1, "realname": 1, "location": 1, "heading": 1, "groundspeed": 1, "altitude": 1}'}
      }
    }

    window.customElements.define(FsnMap.is, FsnMap);
  </script>
</dom-module>
